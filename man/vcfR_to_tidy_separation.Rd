% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vcfR_to_tidy_functions.R
\name{vcfR_to_tidy_separation}
\alias{vcfR_to_tidy_separation}
\alias{extract_ann_cols}
\alias{extract_ann_cols_snpeff}
\alias{extract_ann_cols_vep}
\alias{separate_ann}
\alias{separate_ann_snpeff}
\alias{separate_ann_vep}
\title{Separate annotation columns in a tidy VCF}
\usage{
extract_ann_cols(info, regex, clean_names = TRUE, custom_names = NULL, ...)

extract_ann_cols_snpeff(meta, ...)

extract_ann_cols_vep(meta, ...)

separate_ann(
  df,
  ann_col,
  into_cols,
  field_sep = "\\\\|",
  multi_sep = ",",
  value_fn = NULL,
  add_rank = TRUE,
  return_into_cols = FALSE,
  ...
)

separate_ann_snpeff(df, meta, additional_ann_cols = c("LOF", "NMD"), ...)

separate_ann_vep(df, meta, ...)
}
\arguments{
\item{info}{A character scalar: description of field names from which column names will be deducted.}

\item{regex}{A character scalar: regular expression specifying a group in \code{info} containing the field names.
  The group must be named \code{cols}.

  Example for VEP (CSQ): "Consequence annotations from Ensembl VEP. Format: Allele|Consequence|IMPACT|SYMBOL|..."
  which is matched by regex \code{"Consequence annotations from Ensembl VEP. Format: (?<cols>.+)"}.}

\item{clean_names}{A logical scalar: if \code{TRUE}, the extracted column names are cleaned by
\code{\link[janitor]{make_clean_names}}.}

\item{custom_names}{A named list: used to define custom column renamings.
The form is \code{list("old_name" = "new_name")}, e.g. \code{list("gene_id" = "ensembl_id")}.}

\item{...}{Passed to other functions.}

\item{meta}{A tibble: \code{meta} item in the list returned from \code{vcfR2tidy()}.}

\item{df}{A tibble: should be the \code{fix} item in the list returned from \code{vcfR2tidy()}, or \code{dat} item
if \code{single_frame = TRUE} was used.}

\item{ann_col}{A character scalar: name of column to separate.}

\item{into_cols}{A character vector: names of new columns into which \code{ann_col} will be separated.}

\item{field_sep}{A character scalar: separator of annotation fields.}

\item{multi_sep}{A character scalar: separator of multiple annotations.}

\item{value_fn}{A function to apply to the \code{ann_col} column before the column-wise separation takes place.
It must take two parameters \code{df} and \code{ann_col}, and return a dataframe-like object. Set to \code{NULL}
to disable.}

\item{add_rank}{A logical scalar: if \code{TRUE}, each of per-variant annotations will be ranked (\code{ann_rank} column)
based on the order in which they appear.
See "Effect sort order" \href{http://pcingola.github.io/SnpEff/se_inputoutput/#multiple-annotations-per-vcf-line}{here}.}

\item{return_into_cols}{A logical scalar: if \code{TRUE}, only return the newly separated columns, otherwise the whole
\code{df}.}

\item{additional_ann_cols}{A character vector: additional columns to separate.}
}
\description{
Some VCF annotation tools are storing the variant annotations in INFO column of the VCF file.
The most common annotation tools are probably \href{http://pcingola.github.io/SnpEff/}{snpEff} and
\href{https://www.ensembl.org/info/docs/tools/vep/index.html}{VEP}. The following bunch of functions is able to
extract the names of annotation fields (columns) and separate them into columns. One variant can have multiple
annotations separated by comma. The field (column) names of annotations are stored in the \code{meta} dataframe
returned by \link{vcfR2tidy}.

In general, the two aforementioned tools should follow the
\href{http://pcingola.github.io/SnpEff/adds/VCFannotationformat_v1.0.pdf}{VCF annotation standard for ANN field}
(but the reality is a bit different). See the Details section below for a description of annotation data.
}
\details{
Let \code{vcf_tidy} be the value (named list) returned from the \code{\link{vcfR2tidy}} function and
the underlying VCF was annotated by snpEff or VEP.

In \code{vcf_tidy$meta} (int the \code{ID} and \code{Description} columns), the description of annotation fields is:

\itemize{
  \item For snpEff (see \href{http://pcingola.github.io/SnpEff/se_inputoutput/}{here}):
    \itemize{
      \item ANN: "Functional annotations: 'Allele | Annotation | Annotation_Impact | cDNA.pos / cDNA.length | ...'"
      \item LOF (Loss Of Function): "Predicted loss of function effects for this variant. Format: 'Gene_Name | Gene_ID | Number_of_transcripts_in_gene | Percent_of_transcripts_affected'"
      \item NMD (Nonsense-Mediated Decay): "Predicted nonsense mediated decay effects for this variant. Format: 'Gene_Name | Gene_ID | Number_of_transcripts_in_gene | Percent_of_transcripts_affected'"
    }
  \item For VEP (see \href{https://www.ensembl.org/info/docs/tools/vep/script/vep_options.html#output}{here}):
    \itemize{
      \item CSQ: "Consequence annotations from Ensembl VEP. Format: Allele|Consequence|IMPACT|SYMBOL|..."
    }
}

E.g.
\preformatted{
  vcf_tidy$meta \%>\%
    dplyr::filter(ID == "ANN") \%>\%
    dplyr::pull(Description)
}
will return the field names for the ANN column in \code{vcf_tidy$fix}.

In \code{vcf_tidy$fix}, the annotation data is stored as:
\itemize{
  \item For snpEff (see \href{http://pcingola.github.io/SnpEff/se_inputoutput/}{here}):
    \itemize{
      \item ANN: "C|synonymous_variant|LOW|ATAD3A|...||,C|downstream_gene_|..."
      \item LOF (Loss Of Function): "(ARID1A|ENSG00000117713|1|1.00)"
      \item NMD (Nonsense-Mediated Decay): "(KMT2C|ENSG00000055609|1|1.00)"
    }
  \item For VEP (see \href{https://www.ensembl.org/info/docs/tools/vep/script/vep_options.html#output}{here}):
    \itemize{
      \item CSQ: the same as ANN for snpEff.
    }
}
}
\section{{Extraction of field names}}{

Field names are extracted from \code{vcf_tidy$meta} dataframe.

\code{extract_ann_cols()} is a general-purpose function used underneath by the more specific functions below.

\code{extract_ann_cols_snpeff()} extracts the ANN, LOF and NMD field names from a snpEff-annotated VCF dataframe.
As LOF and NMD field names are similar, those are prefixed by \code{"lof_"} and \code{"nmd_"}, respectively.
Here, \code{...} is passed to \code{extract_ann_cols()}.

\code{extract_ann_cols_vep()} extracts the CSQ field names from a VEP-annotated VCF dataframe.
Here, \code{...} is passed to \code{extract_ann_cols()}.
}

\section{{Separation of annotation columns}}{

Annotation columns are separated in \code{vcf_tidy$fix} or \code{vcf_tidy$dat} dataframe.
The annotation columns are first separated row-wise by comma using \link[tidyr]{separate_rows}
and then column-wise by pipe ("|") using \link[tidyr]{separate}.

\code{separate_ann()} is a general-purpose function for column-wise separation.

\code{separate_ann_snpeff()} separates annotation columns in a snpEff-annotated VCF dataframe. It also does the
field name extraction using \code{extract_ann_cols_snpeff()}. First it separates row-wise the ANN column, followed
by its column-wise separation. Then, by default, the LOF and NMD columns are also separated column-wise.
Here, \code{...} is passed to \code{extract_ann_cols_snpeff()} and \code{separate_ann()} (only for the ANN column).

\code{separate_ann_vep()} separates the CSQ annotation column in a VEP-annotated VCF dataframe. The procedure is
similar to \code{separate_ann_snpeff()}, except no additional columns are separated (as CSQ is the only one produced
by VEP). Here, \code{...} is passed to \code{extract_ann_cols_vep()} and \code{separate_ann()}.
}

\examples{
extract_ann_cols(
  "Functional annotations: 'Allele | Annotation | Annotation_Impact | cDNA.pos / cDNA.length'",
  "^Functional annotations: '(?<cols>.+)'"
)

data("vcfR_test_snpEff")
vcf_snpeff_tidy <- vcfR2tidy(vcfR_test_snpEff)
extract_ann_cols_snpeff(vcf_snpeff_tidy$meta)
extract_ann_cols_snpeff(vcf_snpeff_tidy$meta, clean_names = FALSE)
extract_ann_cols_snpeff(vcf_snpeff_tidy$meta, custom_names = list("gene_id" = "ensembl_id"))

data("vcfR_test_VEP")
vcf_vep_tidy <- vcfR2tidy(vcfR_test_VEP)
vep_ann_cols <- extract_ann_cols_vep(vcf_vep_tidy$meta)
separate_ann(vcf_vep_tidy$fix, "CSQ", vep_ann_cols$CSQ)

data("vcfR_test_snpEff")
vcf_snpeff_tidy <- vcfR2tidy(vcfR_test_snpEff)
separate_ann_snpeff(vcf_snpeff_tidy$fix, vcf_snpeff_tidy$meta)
separate_ann_snpeff(vcf_snpeff_tidy$fix, vcf_snpeff_tidy$meta, additional_ann_cols = NULL)

}
\author{
Jiri Novotny <jiri.novotny@img.cas.cz>
}
